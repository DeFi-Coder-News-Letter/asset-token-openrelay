package types_test

import (
	"database/sql"
	"database/sql/driver"
	"encoding/hex"
	"encoding/json"
	"github.com/notegio/openrelay/types"
	"io/ioutil"
	"reflect"
	"testing"
)

func checkOrder(order *types.Order, t *testing.T) {
	if hex.EncodeToString(order.MakerToken[:]) != "1dad4783cf3fe3085c1426157ab175a6119a04ba" {
		t.Errorf("Unexpected MakerToken")
	}
	if hex.EncodeToString(order.Maker[:]) != "324454186bb728a3ea55750e0618ff1b18ce6cf8" {
		t.Errorf("Unexpected Maker")
	}
	if hex.EncodeToString(order.Taker[:]) != "0000000000000000000000000000000000000000" {
		t.Errorf("Unexpected Taker")
	}
	if hex.EncodeToString(order.FeeRecipient[:]) != "0000000000000000000000000000000000000000" {
		t.Errorf("Unexpected FeeRecipient")
	}
	if hex.EncodeToString(order.TakerToken[:]) != "05d090b51c40b020eab3bfcb6a2dff130df22e9c" {
		t.Errorf("Unexpected TakerToken")
	}
	if hex.EncodeToString(order.ExchangeAddress[:]) != "90fe2af704b34e0224bf2299c838e04d4dcf1364" {
		t.Errorf("Unexpected TakerToken")
	}
	if hex.EncodeToString(order.MakerTokenAmount[:]) != "000000000000000000000000000000000000000000000002b5e3af16b1880000" {
		t.Errorf("Unexpected MakerTokenAmount")
	}
	if hex.EncodeToString(order.TakerTokenAmount[:]) != "0000000000000000000000000000000000000000000000000de0b6b3a7640000" {
		t.Errorf("Unexpected MakerTokenAmount")
	}
	if hex.EncodeToString(order.MakerFee[:]) != "0000000000000000000000000000000000000000000000000000000000000000" {
		t.Errorf("Unexpected MakerFee")
	}
	if hex.EncodeToString(order.TakerFee[:]) != "0000000000000000000000000000000000000000000000000000000000000000" {
		t.Errorf("Unexpected TakerFee")
	}
	if hex.EncodeToString(order.ExpirationTimestampInSec[:]) != "0000000000000000000000000000000000000000000000000000000159938ac4" {
		t.Errorf("Unexpected ExpirationTimestampInSec")
	}
	if hex.EncodeToString(order.Salt[:]) != "000643508ff7019bfb134363a86e98746f6c33262e68daf992b8df064217222b" {
		t.Errorf("Unexpected Salt")
	}
	if order.Signature.V != byte(27) {
		t.Errorf("Unexpected sig.v %v", order.Signature.V)
	}
	if hex.EncodeToString(order.Signature.R[:]) != "021fe6dba378a347ea5c581adcd0e0e454e9245703d197075f5d037d0935ac2e" {
		t.Errorf("Unexpected sig.r")
	}
	if hex.EncodeToString(order.Signature.S[:]) != "12ac107cb04be663f542394832bbcb348deda8b5aa393a97a4cc3139501007f1" {
		t.Errorf("Unexpected sig.s")
	}
	if hex.EncodeToString(order.Hash()) != "731319211689ccf0327911a0126b0af0854570c1b6cdfeb837b0127e29fe9fd5" {
		t.Errorf("Hashes not equal")
	}
	if !order.Signature.Verify(order.Maker) {
		t.Errorf("Signature not valid")
	}
	testOrderBytes, _ := hex.DecodeString("90fe2af704b34e0224bf2299c838e04d4dcf1364324454186bb728a3ea55750e0618ff1b18ce6cf800000000000000000000000000000000000000001dad4783cf3fe3085c1426157ab175a6119a04ba05d090b51c40b020eab3bfcb6a2dff130df22e9c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000002b5e3af16b18800000000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000159938ac4000643508ff7019bfb134363a86e98746f6c33262e68daf992b8df064217222b1b021fe6dba378a347ea5c581adcd0e0e454e9245703d197075f5d037d0935ac2e12ac107cb04be663f542394832bbcb348deda8b5aa393a97a4cc3139501007f1")
	calculatedBytes := order.Bytes()
	if !reflect.DeepEqual(calculatedBytes[:377], testOrderBytes[:377]) {
		t.Errorf("Unexpected byte stream")
	}
}

func TestByteDeserialize(t *testing.T) {
	testOrderBytes, _ := hex.DecodeString("90fe2af704b34e0224bf2299c838e04d4dcf1364324454186bb728a3ea55750e0618ff1b18ce6cf800000000000000000000000000000000000000001dad4783cf3fe3085c1426157ab175a6119a04ba05d090b51c40b020eab3bfcb6a2dff130df22e9c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000002b5e3af16b18800000000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000159938ac4000643508ff7019bfb134363a86e98746f6c33262e68daf992b8df064217222b1b021fe6dba378a347ea5c581adcd0e0e454e9245703d197075f5d037d0935ac2e12ac107cb04be663f542394832bbcb348deda8b5aa393a97a4cc3139501007f1")
	var testOrderByteArray [441]byte
	copy(testOrderByteArray[:], testOrderBytes[:])
	newOrder := types.OrderFromBytes(testOrderByteArray)
	checkOrder(newOrder, t)
}
func TestJSONDeserialize(t *testing.T) {
	newOrder := types.Order{}
	if orderData, err := ioutil.ReadFile("../formatted_transaction.json"); err == nil {
		if err := json.Unmarshal(orderData, &newOrder); err != nil {
			t.Errorf(err.Error())
			return
		}
	}
	checkOrder(&newOrder, t)
}

func value(valuer driver.Valuer) (interface{}, error) {
	return valuer.Value()
}

func scan(scanner sql.Scanner, data []byte) error {
	return scanner.Scan(data)
}

func TestValuerInterfaceAddress(t *testing.T) {
	testOrderBytes, _ := hex.DecodeString("90fe2af704b34e0224bf2299c838e04d4dcf1364324454186bb728a3ea55750e0618ff1b18ce6cf800000000000000000000000000000000000000001dad4783cf3fe3085c1426157ab175a6119a04ba05d090b51c40b020eab3bfcb6a2dff130df22e9c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000002b5e3af16b18800000000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000159938ac4000643508ff7019bfb134363a86e98746f6c33262e68daf992b8df064217222b1b021fe6dba378a347ea5c581adcd0e0e454e9245703d197075f5d037d0935ac2e12ac107cb04be663f542394832bbcb348deda8b5aa393a97a4cc3139501007f1")
	var testOrderByteArray [441]byte
	copy(testOrderByteArray[:], testOrderBytes[:])
	newOrder := types.OrderFromBytes(testOrderByteArray)
	if ExchangeValue, _ := value(newOrder.ExchangeAddress); !reflect.DeepEqual(ExchangeValue, testOrderBytes[:20]) {
		t.Errorf("Unexpected ExchangeAddress")
	}
}

func TestScannerInterfaceAddress(t *testing.T) {
	testOrderBytes, _ := hex.DecodeString("90fe2af704b34e0224bf2299c838e04d4dcf1364324454186bb728a3ea55750e0618ff1b18ce6cf800000000000000000000000000000000000000001dad4783cf3fe3085c1426157ab175a6119a04ba05d090b51c40b020eab3bfcb6a2dff130df22e9c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000002b5e3af16b18800000000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000159938ac4000643508ff7019bfb134363a86e98746f6c33262e68daf992b8df064217222b1b021fe6dba378a347ea5c581adcd0e0e454e9245703d197075f5d037d0935ac2e12ac107cb04be663f542394832bbcb348deda8b5aa393a97a4cc3139501007f1")
	order := types.Order{}
	order.Initialize()
	scan(order.ExchangeAddress, testOrderBytes[:20])
	if !reflect.DeepEqual(order.ExchangeAddress[:], testOrderBytes[:20]) {
		t.Errorf("Failed to load exchange address: %v", hex.EncodeToString(order.ExchangeAddress[:]))
	}
}

func TestValuerInterfaceUint256(t *testing.T) {
	testOrderBytes, _ := hex.DecodeString("90fe2af704b34e0224bf2299c838e04d4dcf1364324454186bb728a3ea55750e0618ff1b18ce6cf800000000000000000000000000000000000000001dad4783cf3fe3085c1426157ab175a6119a04ba05d090b51c40b020eab3bfcb6a2dff130df22e9c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000002b5e3af16b18800000000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000159938ac4000643508ff7019bfb134363a86e98746f6c33262e68daf992b8df064217222b1b021fe6dba378a347ea5c581adcd0e0e454e9245703d197075f5d037d0935ac2e12ac107cb04be663f542394832bbcb348deda8b5aa393a97a4cc3139501007f1")
	var testOrderByteArray [441]byte
	copy(testOrderByteArray[:], testOrderBytes[:])
	newOrder := types.OrderFromBytes(testOrderByteArray)
	if MakerTokenAmount, _ := value(newOrder.MakerTokenAmount); !reflect.DeepEqual(MakerTokenAmount, testOrderBytes[120:152]) {
		t.Errorf("Unexpected MakerTokenAmount")
	}
}

func TestScannerInterfaceUint256(t *testing.T) {
	testOrderBytes, _ := hex.DecodeString("90fe2af704b34e0224bf2299c838e04d4dcf1364324454186bb728a3ea55750e0618ff1b18ce6cf800000000000000000000000000000000000000001dad4783cf3fe3085c1426157ab175a6119a04ba05d090b51c40b020eab3bfcb6a2dff130df22e9c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000002b5e3af16b18800000000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000159938ac4000643508ff7019bfb134363a86e98746f6c33262e68daf992b8df064217222b1b021fe6dba378a347ea5c581adcd0e0e454e9245703d197075f5d037d0935ac2e12ac107cb04be663f542394832bbcb348deda8b5aa393a97a4cc3139501007f1")
	order := types.Order{}
	order.Initialize()
	scan(order.MakerTokenAmount, testOrderBytes[120:152])
	if !reflect.DeepEqual(order.MakerTokenAmount[:], testOrderBytes[120:152]) {
		t.Errorf("Failed to load MakerTokenAmount: %v", hex.EncodeToString(order.MakerTokenAmount[:]))
	}
}

func TestValuerInterfaceSignature(t *testing.T) {
	testOrderBytes, _ := hex.DecodeString("90fe2af704b34e0224bf2299c838e04d4dcf1364324454186bb728a3ea55750e0618ff1b18ce6cf800000000000000000000000000000000000000001dad4783cf3fe3085c1426157ab175a6119a04ba05d090b51c40b020eab3bfcb6a2dff130df22e9c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000002b5e3af16b18800000000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000159938ac4000643508ff7019bfb134363a86e98746f6c33262e68daf992b8df064217222b1b021fe6dba378a347ea5c581adcd0e0e454e9245703d197075f5d037d0935ac2e12ac107cb04be663f542394832bbcb348deda8b5aa393a97a4cc3139501007f1")
	var testOrderByteArray [441]byte
	copy(testOrderByteArray[:], testOrderBytes[:])
	newOrder := types.OrderFromBytes(testOrderByteArray)
	sigValue, _ := value(newOrder.Signature)
	sigBytes := sigValue.([]byte)

	if !reflect.DeepEqual(sigBytes[:32], testOrderBytes[313:345]) {
		t.Errorf("Unexpected Sig R")
	}
	if !reflect.DeepEqual(sigBytes[32:64], testOrderBytes[345:377]) {
		t.Errorf("Unexpected Sig S")
	}
	if sigBytes[64] != byte(int(testOrderBytes[312])-27) {
		t.Errorf("Unexpected Sig V")
	}

}

func TestScannerInterfaceSignature(t *testing.T) {
	testOrderBytes, _ := hex.DecodeString("90fe2af704b34e0224bf2299c838e04d4dcf1364324454186bb728a3ea55750e0618ff1b18ce6cf800000000000000000000000000000000000000001dad4783cf3fe3085c1426157ab175a6119a04ba05d090b51c40b020eab3bfcb6a2dff130df22e9c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000002b5e3af16b18800000000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000159938ac4000643508ff7019bfb134363a86e98746f6c33262e68daf992b8df064217222b1b021fe6dba378a347ea5c581adcd0e0e454e9245703d197075f5d037d0935ac2e12ac107cb04be663f542394832bbcb348deda8b5aa393a97a4cc3139501007f1")
	var testOrderByteArray [441]byte
	copy(testOrderByteArray[:], testOrderBytes[:])

	sigBytes := make([]byte, 65)
	copy(sigBytes[:64], testOrderBytes[313:377])
	sigBytes[64] = byte(int(testOrderBytes[312]) - 27)
	signature := &types.Signature{}
	scan(signature, sigBytes)
	if !reflect.DeepEqual(signature.R[:], sigBytes[:32]) {
		t.Errorf("Unexpected Sig R")
	}
	if !reflect.DeepEqual(signature.S[:], sigBytes[32:64]) {
		t.Errorf("Unexpected Sig S")
	}
	if signature.V != testOrderBytes[312] {
		t.Errorf("Unexpected Sig V")
	}
}

func TestJsonMarshal(t *testing.T) {
	testOrderBytes, _ := hex.DecodeString("90fe2af704b34e0224bf2299c838e04d4dcf1364324454186bb728a3ea55750e0618ff1b18ce6cf800000000000000000000000000000000000000001dad4783cf3fe3085c1426157ab175a6119a04ba05d090b51c40b020eab3bfcb6a2dff130df22e9c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000002b5e3af16b18800000000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000159938ac4000643508ff7019bfb134363a86e98746f6c33262e68daf992b8df064217222b1b021fe6dba378a347ea5c581adcd0e0e454e9245703d197075f5d037d0935ac2e12ac107cb04be663f542394832bbcb348deda8b5aa393a97a4cc3139501007f1")
	var testOrderByteArray [441]byte
	copy(testOrderByteArray[:], testOrderBytes[:])
	newOrder := types.OrderFromBytes(testOrderByteArray)
	data, err := json.Marshal(newOrder)
	if err != nil {
		t.Errorf("Got error marshalling: %v", err.Error())
		return
	}
	if string(data) != "{\"maker\":\"0x324454186bb728a3ea55750e0618ff1b18ce6cf8\",\"taker\":\"0x0000000000000000000000000000000000000000\",\"makerTokenAddress\":\"0x1dad4783cf3fe3085c1426157ab175a6119a04ba\",\"takerTokenAddress\":\"0x05d090b51c40b020eab3bfcb6a2dff130df22e9c\",\"feeRecipient\":\"0x0000000000000000000000000000000000000000\",\"exchangeContractAddress\":\"0x90fe2af704b34e0224bf2299c838e04d4dcf1364\",\"makerTokenAmount\":\"50000000000000000000\",\"takerTokenAmount\":\"1000000000000000000\",\"makerFee\":\"0\",\"takerFee\":\"0\",\"expirationUnixTimestampSec\":\"5797808836\",\"salt\":\"11065671350908846865864045738088581419204014210814002044381812654087807531\",\"ecSignature\":{\"v\":27,\"r\":\"0x021fe6dba378a347ea5c581adcd0e0e454e9245703d197075f5d037d0935ac2e\",\"s\":\"0x12ac107cb04be663f542394832bbcb348deda8b5aa393a97a4cc3139501007f1\"}}" {
		t.Errorf("Got unexpected JSON value: %v", string(data))
	}
}

func TestJsonMarshalSlice(t *testing.T) {
	testOrderBytes, _ := hex.DecodeString("90fe2af704b34e0224bf2299c838e04d4dcf1364324454186bb728a3ea55750e0618ff1b18ce6cf800000000000000000000000000000000000000001dad4783cf3fe3085c1426157ab175a6119a04ba05d090b51c40b020eab3bfcb6a2dff130df22e9c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000002b5e3af16b18800000000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000159938ac4000643508ff7019bfb134363a86e98746f6c33262e68daf992b8df064217222b1b021fe6dba378a347ea5c581adcd0e0e454e9245703d197075f5d037d0935ac2e12ac107cb04be663f542394832bbcb348deda8b5aa393a97a4cc3139501007f1")
	var testOrderByteArray [441]byte
	copy(testOrderByteArray[:], testOrderBytes[:])
	newOrder := types.OrderFromBytes(testOrderByteArray)
	orderList := []types.Order{*newOrder}
	data, err := json.Marshal(orderList)
	if err != nil {
		t.Errorf("Got error marshalling: %v", err.Error())
		return
	}
	if string(data) != "[{\"maker\":\"0x324454186bb728a3ea55750e0618ff1b18ce6cf8\",\"taker\":\"0x0000000000000000000000000000000000000000\",\"makerTokenAddress\":\"0x1dad4783cf3fe3085c1426157ab175a6119a04ba\",\"takerTokenAddress\":\"0x05d090b51c40b020eab3bfcb6a2dff130df22e9c\",\"feeRecipient\":\"0x0000000000000000000000000000000000000000\",\"exchangeContractAddress\":\"0x90fe2af704b34e0224bf2299c838e04d4dcf1364\",\"makerTokenAmount\":\"50000000000000000000\",\"takerTokenAmount\":\"1000000000000000000\",\"makerFee\":\"0\",\"takerFee\":\"0\",\"expirationUnixTimestampSec\":\"5797808836\",\"salt\":\"11065671350908846865864045738088581419204014210814002044381812654087807531\",\"ecSignature\":{\"v\":27,\"r\":\"0x021fe6dba378a347ea5c581adcd0e0e454e9245703d197075f5d037d0935ac2e\",\"s\":\"0x12ac107cb04be663f542394832bbcb348deda8b5aa393a97a4cc3139501007f1\"}}]" {
		t.Errorf("Got unexpected JSON value: %v", string(data))
	}
}
